# RISC-V Processor and UVM Verification Environment

This document describes the **classic UVM approach** used for the RISC-V processor verification.

## UVM Classic Implementation

The `uvm_classic/` directory contains a complete, **active UVM testbench**. This environment has evolved from its original passive implementation into a more robust, stimulus-driven verification framework.

### Overview

This implementation uses an **active, dual-path UVM methodology**:

1.  **Flow Path (Active Stimulus & PC Checking)**: An active agent drives compiled `riscv-dv` test programs to the DUT. In parallel, it uses a predictor and scoreboard to perform cycle-by-cycle checking of the program counter (PC) flow.
2.  **Commit Path (Passive Golden Model Checking)**: A passive agent monitors the DUT's commit stage, comparing every retired instruction against a golden trace file generated by the Spike ISA simulator.

### Architecture

The environment separates the concerns of stimulus generation and end-to-end checking, following a standard hierarchical UVM structure.

```mermaid
graph TB
    subgraph Test [riscv_base_test]
        
        Configuration[riscv_dut_config]

        subgraph Environment [cpu_env]
            
            subgraph "Flow Agent (Active)"
                flow_sequencer[Sequencer]
                flow_driver[Driver]
                flow_monitor[Monitor]
            end

            subgraph "Checking Components"
                predictor[Predictor]
                scoreboard[Scoreboard]
                coverage[Coverage]
            end
            
            subgraph "Commit Agent (Passive)"
                commit_monitor[Monitor]
            end

            flow_monitor -- "Actual PC" --> predictor
            predictor -- "Predicted PC" --> scoreboard
            flow_monitor -- "Actual PC" --> scoreboard
            commit_monitor -- "Instruction Commit" --> scoreboard
            flow_monitor & commit_monitor -- "Observed Events" --> coverage
        end
        
        Sequence[riscv_memory_file_sequence] --> flow_sequencer
    end

    flow_driver -- "Drives Instructions" --> DUT[DUT: RISC-V Core]
    DUT -- "Is Observed by" --> flow_monitor
    DUT -- "Is Observed by" --> commit_monitor
```

### Key Features

- **Active Stimulus Generation**: The UVM testbench directly drives instructions from a compiled test program, replacing the hardware instruction memory.
- **Dual-Path Verification**: Combines low-level, cycle-accurate PC flow checking with high-level, end-to-end commit validation against a golden model.
- **Spike-Based Golden Reference**: Uses traces from the Spike simulator for robust, bit-accurate, end-to-end checking in the `commit_scoreboard`.
- **Hardware Data Memory**: The original `data_memory.v` module remains in the testbench to verify load/store instruction functionality.
- **Known Limitation**: The `flow_predictor` is a work-in-progress and currently only predicts sequential (PC+4) program flow. It will report false errors on branches and jumps. The commit path provides the primary verification.

## Quick Start

### 1. UVM Smoke Test (No external test program)
```bash
make uvm_smoke
```

### 2. UVM Regression with Generated Test Program
```bash
make uvm_regress
```

This command will:
- Generate a random test program
- Compile it to memory format
- Run Spike reference simulation
- Run UVM testbench and compare results

### 3. Using Specific Seed (Recommended for Testing)
```bash
mkdir -p logs
echo "846056" > logs/seeds.txt
PRESERVE_SEEDS=1 make uvm_regress
```

## Project Structure

The `uvm_classic` directory is organized by UVM component type:

```
uvm_classic/
├── uvm_top.sv               # Top-level testbench, connects DUT and UVM test
├── cpu_top.sv               # DUT wrapper, instantiates the processor
├── cpu_interface.sv         # SystemVerilog interface for DUT connections
├── riscv_uvm_pkg.sv         # UVM package, imports all class files
│
├── agents/                  # UVM agents (containers for drivers, sequencers, monitors)
│   ├── cpu_flow_agent.sv    # ACTIVE agent for driving stimulus
│   └── cpu_commit_agent.sv  # PASSIVE agent for monitoring commit
│
├── config/                  # Configuration objects
│   └── riscv_dut_config.sv  # Holds test-specific configuration data
│
├── drivers/                 # Drives signals to the DUT
│   └── cpu_instruction_driver.sv # Drives instructions from the sequence to the DUT
│
├── env/                     # UVM environment
│   └── cpu_env.sv           # Instantiates and connects all agents and scoreboards
│
├── monitors/                # Passively observe DUT signals
│   ├── cpu_flow_monitor.sv  # Monitors PC and instruction fetch
│   └── cpu_commit_monitor.sv # Monitors final instruction commit/write-back
│
├── predictors/              # Predicts DUT behavior for online checking
│   └── cpu_flow_predictor.sv # Predicts next_PC based on current instruction
│
├── sequences/               # Generate stimulus
│   └── riscv_instruction_sequences.sv # Sequence to read and drive a test from a file
│
├── sequencers/              # Arbitrate between sequences
│   └── cpu_instruction_sequencer.sv # Manages transaction flow to the driver
│
├── subscribers/             # Components that receive data (scoreboards, etc.)
│   ├── cpu_flow_scoreboard.sv  # Compares actual PC flow vs. predicted flow
│   └── cpu_commit_scoreboard.sv # Compares actual commit vs. Spike golden log
│
├── tests/                   # UVM tests
│   └── riscv_base_test.sv   # Base test, configures environment and starts sequence
│
└── transactions/            # Data objects for communication
    ├── riscv_instruction_transaction.sv # For instructions from sequencer to driver
    ├── riscv_flow_transaction.sv        # For PC data from flow_monitor to flow_scoreboard
    └── riscv_commit_transaction.sv      # For commit data from commit_monitor to commit_scoreboard
```

### Traditional Script-Based Approach
- `uvm_scripted_flow/tb_top.sv` - Original working script-based testbench
- `uvm_scripted_flow/cpu_top.sv` - Original DUT wrapper

## Environment Requirements

Ensure these environment variables are set (in `.env` file):
- `QUESTA_HOME` - Path to Questa installation
- `UVM_HOME` - Path to UVM library  
- `HOST_CC_PATH` - Path to C++ compiler

## Expected Output

Successful UVM run should show:
- PC MATCH messages for each instruction
- ECALL detection and graceful termination  
- UVM_INFO messages with zero UVM_ERRORs
- Clean test completion

### Example Report Summary (Seed 846056)

A successful run will end with a UVM report summary indicating zero errors or fatals, like the one below for a test generated with seed `846056`:

```
# --- UVM Report Summary ---
#
# ** Report counts by severity
# UVM_INFO :13278
# UVM_WARNING :    0
# UVM_ERROR :    0
# UVM_FATAL :    0
# ** Report counts by id
# [AGENT]     2
# [CONFIG]     4
# [DRIVER]     2
# [ENV]     2
# [Questa UVM]     2
# [RNTST]     1
# [TEST]     7
# [TEST_DONE]     1
# [UVM/RELNOTES]     1
# [cpu_commit_scoreboard]  8832
# [cpu_flow_predictor]     1
# [cpu_flow_scoreboard]  4420
# [riscv_memory_file_sequence]     3
```

#### Understanding the Report

This summary provides a vital snapshot of the test run's health:

-   **Report counts by severity**: This is the most important section.
    -   `UVM_INFO`: These are informational messages used for tracing and debugging. A high count is normal and shows the testbench was active.
    -   `UVM_ERROR`: This indicates a functional mismatch or a check failure. A passing test **must have zero** errors.
    -   `UVM_FATAL`: This indicates a critical problem that stopped the simulation. A passing test **must have zero** fatal errors.

-   **Report counts by id**: This tells you which component generated the messages.
    -   A high number of messages from components like `cpu_commit_scoreboard` and `cpu_flow_scoreboard` is a **good sign**. It means thousands of successful checks were performed (e.g., matching the DUT's behavior against the Spike model), confirming the processor's correctness for this specific test.
    -   The other IDs show that all major components of the testbench (agents, drivers, sequences, environment) were active during the run.
-   **Report counts by id**: This breaks down the `UVM_INFO` messages by their source component, giving insight into the test's execution.
    -   `[cpu_commit_scoreboard] 8832`: This high number is the primary indicator of a successful test run. It shows that for every instruction executed, the scoreboard performed multiple checks (e.g., verifying the program counter, instruction opcode, and register write-back data) and all of them matched the Spike golden model.
    -   `[cpu_flow_scoreboard] 4420`: This number confirms that thousands of successful cycle-by-cycle checks were performed on the program counter's flow, ensuring instructions were fetched correctly.
    -   The low counts for other components like `[AGENT] (2)`, `[CONFIG] (4)`, and `[TEST] (7)` are also expected. These are typically setup and status messages confirming that the various parts of the UVM environment were built and configured correctly at the start and end of the test. A count of `1` for `[TEST_DONE]` is a key indicator that the test reached its intended conclusion without terminating early.
